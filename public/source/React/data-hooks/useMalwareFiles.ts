import { useQuery } from '@tanstack/react-query';
import { MALWARE_FILES } from 'constants/queryKeys';
import { API } from 'utils/helpers/api';
import useStoredqueries, { StoredQueryPayload } from './useStoredqueries';
import useJobDefinitions, { JobDefinitionsPayload } from './useJobDefinitions';
import useJobinstances from './useJobinstances';
import { CSEvent, CSEventDetails, CSLocation } from './useEvents';

const formatstr = JSON.stringify([
  {
    report_values: [
      { property: 25, sum_function: 2 },
      { property: 87, sum_function: 2 },
      { property: 26, sum_function: 2 },
      { property: 160, sum_function: 2 }
    ],
    axes: [
      {
        property: 89,
        user_expression: "path+'::'+filename+'::'+contsig+'::'+malwaredisctime"
      }
    ]
  }
]);

const getStoredQueryPayload = (): StoredQueryPayload => {
  return {
    author: 'Index Engines Inc.',
    description: 'This query aims to locate malware-infected files.',
    global: 1,
    graphmode: 'together',
    kftmode: 'all',
    production: 'Both',
    qname: `DETECT_MALWARE_FILES_${Date.now()}`,
    query: 'kft:malware NOT kft:nsrl activetime:0d..0d',
    regexlang: 'simple',
    user_query: 'kft:malware NOT kft:nsrl activetime:0d..0d',
    view: 'responsive',
    orderby: 'unsorted'
  };
};
const getJobDefinitionsPayload = (
  qname: string,
  indexdb: string | undefined,
  id: number | undefined,
  tapedb: string | undefined
): JobDefinitionsPayload => {
  return {
    qjob: {
      email: '',
      descript: 'This job aims to locate malware-infected files',
      format: 'reports',
      formatstr,
      global: 1,
      ie_index: {
        id,
        indexdb,
        tapedb
      },
      qname
    }
  };
};

const getEventDetailsObject = (): CSEventDetails => {
  return {
    backup_time: -1,
    backupset_name: '',
    cleared: false,
    cleartime: -1,
    engineid: '',
    id: '',
    timedate: -1,
    isPolicyDeleted: false,
    type: 'Malware File Detected'
  };
};

const getEventDetails = (bins: any[]): CSEvent[] => {
  const events: CSEvent[] = [];

  bins.forEach((bin: any, index) => {
    const [hostpath, file, signature] = (bin.range.exactly || []).split('::');
    const splitPath = hostpath.split('/');
    const host = splitPath[0];
    const path = splitPath.slice(1).join('/');
    const locations: CSLocation = { host, path };
    const details: CSEventDetails = getEventDetailsObject();

    if (bin.values && bin.values.length > 3) {
      const { s: backupsetName } = bin.values[1];
      const { t: backupTime } = bin.values[2];
      const { t: malewareDetectionTime } = bin.values[3];

      details.backupset_name = backupsetName;
      details.backup_time = backupTime;
      details.timedate = malewareDetectionTime;
      details.file = file;
      details.signature = signature;
    }
    details.id = `Maleware-${index}`;

    events.push({ event_details: details, locations, severity: 'Critical' });
  });
  return events;
};

interface Params {
  session: string;
  fedid: string | undefined;
  indexid: number | undefined;
  tapedb: string | undefined;
}

export default function useMalwareFiles({
  session,
  fedid,
  indexid,
  tapedb
}: Params) {
  const storedqueries = useStoredqueries(session, fedid, indexid);
  const jobDefinitions = useJobDefinitions(session);
  const jobInstances = useJobinstances(session);
  return useQuery({
    queryKey: [MALWARE_FILES, session],
    queryFn: async () => {
      const storedQueriesPayload = getStoredQueryPayload();
      const jobDefinitionsPayload = getJobDefinitionsPayload(
        storedQueriesPayload.qname,
        fedid,
        indexid,
        tapedb
      );

      await storedqueries.mutateAsync(storedQueriesPayload);

      const {
        data: { qjobdefid }
      } = await jobDefinitions.mutateAsync(jobDefinitionsPayload);

      const {
        data: { qjobinstid }
      } = await jobInstances.mutateAsync(qjobdefid);

      const { data } = await API.get(`/queries/jobinstances/${qjobinstid}`, {
        headers: {
          sessionId: session,
          format: 'reports',
          proddupflags: 'path',
          formatstr
        }
      });
      const events: CSEvent[] = [];
      if (data?.result?.ie_qdata?.ie_reports?.reports?.length > 0) {
        events.push(
          ...getEventDetails(data.result.ie_qdata.ie_reports.reports[0].bins)
        );
      }
      return events;
    },
    enabled: session !== '' && fedid !== undefined && indexid !== undefined,
    refetchInterval: 60000
  });
}
